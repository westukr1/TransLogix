 const calculateRoute = async () => {
    if (selectedRequests.length < 2) {
      alert(t("minimum_points_required"));
      return;
    }
  
    if (!routeSettings) {
      alert(t("settings_not_loaded"));
      console.warn("‚ùå routeSettings –≤—ñ–¥—Å—É—Ç–Ω—ñ–π");
      return;
    }
  
    console.log("üîç –û—Ç—Ä–∏–º–∞–Ω—ñ –æ–±–º–µ–∂–µ–Ω–Ω—è –º–∞—Ä—à—Ä—É—Ç—É:", routeSettings);
    const restrictionsCheck = checkRouteRestrictions(routeSettings, selectedRequests);
    if (!restrictionsCheck.isValid) {
      const violationsList = restrictionsCheck.violated.map(v => `‚Ä¢ ${t(v)}`).join("\n");
      alert(t("violated_constraints") + ":\n" + violationsList);
      console.warn("‚ùå –í–∏—è–≤–ª–µ–Ω–æ –ø–æ—Ä—É—à–µ–Ω–Ω—è:", restrictionsCheck.violated);
      return;
    }
  
    const direction = directionFilter;
    let origin, destination, waypoints;
  
    if (direction === "HOME_TO_WORK") {
      origin = `${selectedRequests[0].pickup_latitude},${selectedRequests[0].pickup_longitude}`;
      destination = `${selectedRequests[selectedRequests.length - 1].dropoff_latitude},${selectedRequests[selectedRequests.length - 1].dropoff_longitude}`;
      waypoints = selectedRequests.slice(1, -1).map((r) => `${r.pickup_latitude},${r.pickup_longitude}`);
    } else {
      origin = `${selectedRequests[0].pickup_latitude},${selectedRequests[0].pickup_longitude}`;
      destination = `${selectedRequests[selectedRequests.length - 1].dropoff_latitude},${selectedRequests[selectedRequests.length - 1].dropoff_longitude}`;
      waypoints = selectedRequests.slice(1, -1).map((r) => `${r.dropoff_latitude},${r.dropoff_longitude}`);
    }
  
    console.log("üì§ –í—ñ–¥–ø—Ä–∞–≤–∫–∞ –∑–∞–ø–∏—Ç—É –Ω–∞ —Ä–æ–∑—Ä–∞—Ö—É–Ω–æ–∫ –º–∞—Ä—à—Ä—É—Ç—É:");
    console.log("üìå Origin:", origin);
    console.log("üìå Destination:", destination);
    console.log("üìå Waypoints:", waypoints);
    console.log("üìå Language:", userLanguage);
  
    try {
      const token = localStorage.getItem('access_token');
      const response = await axios.post(API_ENDPOINTS.calculateRoute, {
        origin,
        destination,
        waypoints,
        language: userLanguage,
        passenger_count: selectedRequests.length,
      },
      {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      }
    );
    
  
      console.log("‚úÖ –û—Ç—Ä–∏–º–∞–Ω–æ –º–∞—Ä—à—Ä—É—Ç:", response.data);
  
      const formatAddress = (address) => {
        const parts = address.split(",");
        if (parts.length >= 3) {
          const street = parts[0].trim();
          const house = parts[1].trim();
          const city = parts[2].trim();
          return `${city}, ${street}, ${house}`;
        }
        return address;
      };
  
      const formatDuration = (minutes) => {
        const hours = Math.floor(minutes / 60);
        const remainingMinutes = Math.round(minutes % 60);
        return `${hours}h ${remainingMinutes}m`;
      };
  
      const { standard_route, optimized_route, optimization_applied } = response.data;
  
      if (!standard_route) {
        alert("–ü–æ–º–∏–ª–∫–∞: –î–∞–Ω—ñ –º–∞—Ä—à—Ä—É—Ç—É –Ω–µ –æ—Ç—Ä–∏–º–∞–Ω—ñ.");
        return;
      }
  
      setModalData({
        show: true,
        standardRoute: {
          distance: Math.round(standard_route.total_distance),
          duration: formatDuration(standard_route.total_duration),
          stops: standard_route.stops,
          startAddress: formatAddress(standard_route.start_address),
          endAddress: formatAddress(standard_route.end_address),
        },
        optimizedRoute: optimization_applied
          ? {
              distance: Math.round(optimized_route.total_distance),
              duration: formatDuration(optimized_route.total_duration),
              stops: optimized_route.stops,
              startAddress: formatAddress(optimized_route.start_address),
              endAddress: formatAddress(optimized_route.end_address),
            }
          : null,
        optimizedOrder: response.data.optimized_order || null,
        optimizationApplied: optimization_applied,
      });
  
      setStandardRoute(standard_route || []);
      setOptimizedRoute(optimized_route || []);
    } catch (error) {
      console.error("‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—Ä–∏ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫—É –º–∞—Ä—à—Ä—É—Ç—É:", error);
      alert(t("error_calculating_route"));
    }
  };
  